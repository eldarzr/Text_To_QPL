"QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nHow many heads of the departments are older than 56 ?\n\nQPL Plan:\n#1 = Scan Table [ head ] Predicate [ age > 56.0 ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]\n\nExample 2:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the name, born state and age of the heads of departments ordered by age.\n\nQPL Plan:\n#1 = Scan Table [ head ] Output [ age , name , born_state ] ; #2 = Sort [ #1 ] OrderBy [ age ASC ] Output [ age , name , born_state ]\n\nExample 3:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nList the creation year, name and budget of each department.\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Creation , Budget_in_Billions , Name ]\n\nExample 4:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat are the maximum and minimum budget of the departments?\n\nQPL Plan:\n#1 = Scan Table [ department ] Output [ Budget_in_Billions ] ; #2 = Aggregate [ #1 ] Output [ MAX(Budget_in_Billions) AS Max_Budget_in_Billions , MIN(Budget_in_Billions) AS Min_Budget_in_Billions ]\n\nExample 5:\n\nSchema: \ntable department : Department_ID , Name , Creation , Ranking , Budget_in_Billions , Num_Employees \ntable head : head_ID , name , born_state , age \ntable management : department_ID , head_ID , temporary_acting\nPrimary keys of columns:\ndepartment : Department_ID\nhead : head_ID\nmanagement : department_ID\nForeign keys of columns:\nmanagement : head_ID equals head : head_ID\nmanagement : department_ID equals department : Department_ID\nQuestion:\nWhat is the average number of employees of the departments whose rank is between 10 and 15?\n\nQPL Plan:\n#1 = Scan Table [ department ] Predicate [ Ranking >= 10 AND Ranking <= 15 ] Output [ Ranking , Num_Employees ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_Employees) AS Avg_Num_Employees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable flight : flno , origin , destination , distance , departure_date , arrival_date , price , aid \ntable aircraft : aid , name , distance \ntable employee : eid , name , salary \ntable certificate : eid , aid\nPrimary keys of columns:\nflight : flno\naircraft : aid\nemployee : eid\ncertificate : eid\nForeign keys of columns:\nflight : aid equals aircraft : aid\ncertificate : aid equals aircraft : aid\ncertificate : eid equals employee : eid\nQuestion:\nShow all flight number from Los Angeles.\n\nQPL Plan:\n#1 = Scan Table [ flight ] Predicate [ origin = 'Los Angeles' ] Output [ flno , origin ]\n\nExample 2:\n\nSchema: \ntable Allergy_Type : Allergy , AllergyType \ntable Has_Allergy : StuID , Allergy \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code\nPrimary keys of columns:\nAllergy_Type : Allergy\nHas_Allergy : \nStudent : StuID\nForeign keys of columns:\nHas_Allergy : Allergy equals Allergy_Type : Allergy\nHas_Allergy : StuID equals Student : StuID\nQuestion:\nShow all allergies with number of students affected.\n\nQPL Plan:\n#1 = Scan Table [ Has_Allergy ] Output [ Allergy ] ; #2 = Aggregate [ #1 ] GroupBy [ Allergy ] Output [ Allergy , countstar AS Count_Star ]\n\nExample 3:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable flight : flno , origin , destination , distance , departure_date , arrival_date , price , aid \ntable aircraft : aid , name , distance \ntable employee : eid , name , salary \ntable certificate : eid , aid\nPrimary keys of columns:\nflight : flno\naircraft : aid\nemployee : eid\ncertificate : eid\nForeign keys of columns:\nflight : aid equals aircraft : aid\ncertificate : aid equals aircraft : aid\ncertificate : eid equals employee : eid\nQuestion:\nShow all flight number from Los Angeles.\n\nQPL Plan:\n#1 = Scan Table [ flight ] Predicate [ origin = 'Los Angeles' ] Output [ flno , origin ]\n\nExample 2:\n\nSchema: \ntable Allergy_Type : Allergy , AllergyType \ntable Has_Allergy : StuID , Allergy \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code\nPrimary keys of columns:\nAllergy_Type : Allergy\nHas_Allergy : \nStudent : StuID\nForeign keys of columns:\nHas_Allergy : Allergy equals Allergy_Type : Allergy\nHas_Allergy : StuID equals Student : StuID\nQuestion:\nShow all allergies with number of students affected.\n\nQPL Plan:\n#1 = Scan Table [ Has_Allergy ] Output [ Allergy ] ; #2 = Aggregate [ #1 ] GroupBy [ Allergy ] Output [ Allergy , countstar AS Count_Star ]\n\nExample 3:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nLet's think step by step to convert QPL plan to natural language plan given schema, question, and QPL that describe the question.\n\nIn the natural language plan:\n1. You must have exactly the same number of questions as there are steps in the QPL.\n2. The questions you generate must follow exactly the same order as the steps in the QPL.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nFind the number of dog pets that are raised by female students (with sex F).\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nFind the number of dog pets that are raised by female students (with sex F).\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nFind the number of dog pets that are raised by female students (with sex F).\n\nQPL Plan:\n{qpl}\n\n""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nFind the number of dog pets that are raised by female students (with sex F).\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the name of the country with the most car makers?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the name of the country with the most car makers?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable airlines : uid , Airline , Abbreviation , Country \ntable airports : City , AirportCode , AirportName , Country , CountryAbbrev \ntable flights : Airline , FlightNo , SourceAirport , DestAirport\nPrimary keys of columns:\nairlines : uid\nairports : AirportCode\nflights : Airline\nForeign keys of columns:\nflights : DestAirport equals airports : AirportCode\nflights : SourceAirport equals airports : AirportCode\nQuestion:\nGive the code of the airport with the least flights.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable airlines : uid , Airline , Abbreviation , Country \ntable airports : City , AirportCode , AirportName , Country , CountryAbbrev \ntable flights : Airline , FlightNo , SourceAirport , DestAirport\nPrimary keys of columns:\nairlines : uid\nairports : AirportCode\nflights : Airline\nForeign keys of columns:\nflights : DestAirport equals airports : AirportCode\nflights : SourceAirport equals airports : AirportCode\nQuestion:\nGive the code of the airport with the least flights.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable employee : Employee_ID , Name , Age , City \ntable shop : Shop_ID , Name , Location , District , Number_products , Manager_name \ntable hiring : Shop_ID , Employee_ID , Start_from , Is_full_time \ntable evaluation : Employee_ID , Year_awarded , Bonus\nPrimary keys of columns:\nemployee : Employee_ID\nshop : Shop_ID\nhiring : Employee_ID\nevaluation : Employee_ID\nForeign keys of columns:\nhiring : Employee_ID equals employee : Employee_ID\nhiring : Shop_ID equals shop : Shop_ID\nevaluation : Employee_ID equals employee : Employee_ID\nQuestion:\nWhich employee received the most awards in evaluations? Give me the employee name.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable employee : Employee_ID , Name , Age , City \ntable shop : Shop_ID , Name , Location , District , Number_products , Manager_name \ntable hiring : Shop_ID , Employee_ID , Start_from , Is_full_time \ntable evaluation : Employee_ID , Year_awarded , Bonus\nPrimary keys of columns:\nemployee : Employee_ID\nshop : Shop_ID\nhiring : Employee_ID\nevaluation : Employee_ID\nForeign keys of columns:\nhiring : Employee_ID equals employee : Employee_ID\nhiring : Shop_ID equals shop : Shop_ID\nevaluation : Employee_ID equals employee : Employee_ID\nQuestion:\nWhich employee received the most awards in evaluations? Give me the employee name.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Ref_Template_Types : Template_Type_Code , Template_Type_Description \ntable Templates : Template_ID , Version_Number , Template_Type_Code , Date_Effective_From , Date_Effective_To , Template_Details \ntable Documents : Document_ID , Template_ID , Document_Name , Document_Description , Other_Details \ntable Paragraphs : Paragraph_ID , Document_ID , Paragraph_Text , Other_Details\nPrimary keys of columns:\nRef_Template_Types : Template_Type_Code\nTemplates : Template_ID\nDocuments : Document_ID\nParagraphs : Paragraph_ID\nForeign keys of columns:\nTemplates : Template_Type_Code equals Ref_Template_Types : Template_Type_Code\nDocuments : Template_ID equals Templates : Template_ID\nParagraphs : Document_ID equals Documents : Document_ID\nQuestion:\nReturn the id and type code of the template that is used for the greatest number of documents.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Ref_Template_Types : Template_Type_Code , Template_Type_Description \ntable Templates : Template_ID , Version_Number , Template_Type_Code , Date_Effective_From , Date_Effective_To , Template_Details \ntable Documents : Document_ID , Template_ID , Document_Name , Document_Description , Other_Details \ntable Paragraphs : Paragraph_ID , Document_ID , Paragraph_Text , Other_Details\nPrimary keys of columns:\nRef_Template_Types : Template_Type_Code\nTemplates : Template_ID\nDocuments : Document_ID\nParagraphs : Paragraph_ID\nForeign keys of columns:\nTemplates : Template_Type_Code equals Ref_Template_Types : Template_Type_Code\nDocuments : Template_ID equals Templates : Template_ID\nParagraphs : Document_ID equals Documents : Document_ID\nQuestion:\nReturn the id and type code of the template that is used for the greatest number of documents.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Ref_Template_Types : Template_Type_Code , Template_Type_Description \ntable Templates : Template_ID , Version_Number , Template_Type_Code , Date_Effective_From , Date_Effective_To , Template_Details \ntable Documents : Document_ID , Template_ID , Document_Name , Document_Description , Other_Details \ntable Paragraphs : Paragraph_ID , Document_ID , Paragraph_Text , Other_Details\nPrimary keys of columns:\nRef_Template_Types : Template_Type_Code\nTemplates : Template_ID\nDocuments : Document_ID\nParagraphs : Paragraph_ID\nForeign keys of columns:\nTemplates : Template_Type_Code equals Ref_Template_Types : Template_Type_Code\nDocuments : Template_ID equals Templates : Template_ID\nParagraphs : Document_ID equals Documents : Document_ID\nQuestion:\nWhat is the document id and name with greatest number of paragraphs?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Ref_Template_Types : Template_Type_Code , Template_Type_Description \ntable Templates : Template_ID , Version_Number , Template_Type_Code , Date_Effective_From , Date_Effective_To , Template_Details \ntable Documents : Document_ID , Template_ID , Document_Name , Document_Description , Other_Details \ntable Paragraphs : Paragraph_ID , Document_ID , Paragraph_Text , Other_Details\nPrimary keys of columns:\nRef_Template_Types : Template_Type_Code\nTemplates : Template_ID\nDocuments : Document_ID\nParagraphs : Paragraph_ID\nForeign keys of columns:\nTemplates : Template_Type_Code equals Ref_Template_Types : Template_Type_Code\nDocuments : Template_ID equals Templates : Template_ID\nParagraphs : Document_ID equals Documents : Document_ID\nQuestion:\nWhat is the document id and name with greatest number of paragraphs?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable museum : Museum_ID , Name , Num_of_Staff , Open_Year \ntable visitor : ID , Name , Level_of_membership , Age \ntable visit : Museum_ID , visitor_ID , Num_of_Ticket , Total_spent\nPrimary keys of columns:\nmuseum : Museum_ID\nvisitor : ID\nvisit : Museum_ID\nForeign keys of columns:\nvisit : visitor_ID equals visitor : ID\nvisit : Museum_ID equals museum : Museum_ID\nQuestion:\nWhat are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable museum : Museum_ID , Name , Num_of_Staff , Open_Year \ntable visitor : ID , Name , Level_of_membership , Age \ntable visit : Museum_ID , visitor_ID , Num_of_Ticket , Total_spent\nPrimary keys of columns:\nmuseum : Museum_ID\nvisitor : ID\nvisit : Museum_ID\nForeign keys of columns:\nvisit : visitor_ID equals visitor : ID\nvisit : Museum_ID equals museum : Museum_ID\nQuestion:\nWhat are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable battle : id , name , date , bulgarian_commander , latin_commander , result \ntable ship : lost_in_battle , id , name , tonnage , ship_type , location , disposition_of_ship \ntable death : caused_by_ship_id , id , note , killed , injured\nPrimary keys of columns:\nbattle : id\nship : id\ndeath : id\nForeign keys of columns:\nship : lost_in_battle equals battle : id\ndeath : caused_by_ship_id equals ship : id\nQuestion:\nHow many battles did not lose any ship with tonnage '225'?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable battle : id , name , date , bulgarian_commander , latin_commander , result \ntable ship : lost_in_battle , id , name , tonnage , ship_type , location , disposition_of_ship \ntable death : caused_by_ship_id , id , note , killed , injured\nPrimary keys of columns:\nbattle : id\nship : id\ndeath : id\nForeign keys of columns:\nship : lost_in_battle equals battle : id\ndeath : caused_by_ship_id equals ship : id\nQuestion:\nHow many battles did not lose any ship with tonnage '225'?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Addresses : address_id , line_1 , line_2 , line_3 , city , zip_postcode , state_province_county , country , other_address_details \ntable Courses : course_id , course_name , course_description , other_details \ntable Departments : department_id , department_name , department_description , other_details \ntable Degree_Programs : degree_program_id , department_id , degree_summary_name , degree_summary_description , other_details \ntable Sections : section_id , course_id , section_name , section_description , other_details \ntable Semesters : semester_id , semester_name , semester_description , other_details \ntable Students : student_id , current_address_id , permanent_address_id , first_name , middle_name , last_name , cell_mobile_number , email_address , ssn , date_first_registered , date_left , other_student_details \ntable Student_Enrolment : student_enrolment_id , degree_program_id , semester_id , student_id , other_details \ntable Student_Enrolment_Courses : student_course_id , course_id , student_enrolment_id \ntable Transcripts : transcript_id , transcript_date , other_details \ntable Transcript_Contents : student_course_id , transcript_id\nPrimary keys of columns:\nAddresses : address_id\nCourses : course_id\nDepartments : department_id\nDegree_Programs : degree_program_id\nSections : section_id\nSemesters : semester_id\nStudents : student_id\nStudent_Enrolment : student_enrolment_id\nStudent_Enrolment_Courses : student_course_id\nTranscripts : transcript_id\nTranscript_Contents : \nForeign keys of columns:\nDegree_Programs : department_id equals Departments : department_id\nSections : course_id equals Courses : course_id\nStudents : permanent_address_id equals Addresses : address_id\nStudents : current_address_id equals Addresses : address_id\nStudent_Enrolment : student_id equals Students : student_id\nStudent_Enrolment : semester_id equals Semesters : semester_id\nStudent_Enrolment : degree_program_id equals Degree_Programs : degree_program_id\nStudent_Enrolment_Courses : student_enrolment_id equals Student_Enrolment : student_enrolment_id\nStudent_Enrolment_Courses : course_id equals Courses : course_id\nTranscript_Contents : transcript_id equals Transcripts : transcript_id\nTranscript_Contents : student_course_id equals Student_Enrolment_Courses : student_course_id\nQuestion:\nFind the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Addresses : address_id , line_1 , line_2 , line_3 , city , zip_postcode , state_province_county , country , other_address_details \ntable Courses : course_id , course_name , course_description , other_details \ntable Departments : department_id , department_name , department_description ( in ) , other_details \ntable Degree_Programs : degree_program_id , department_id , degree_summary_name , degree_summary_description , other_details \ntable Sections : section_id , course_id , section_name , section_description , other_details \ntable Semesters : semester_id , semester_name , semester_description , other_details \ntable Students : student_id , current_address_id , permanent_address_id , first_name , middle_name , last_name , cell_mobile_number , email_address , ssn , date_first_registered , date_left , other_student_details \ntable Student_Enrolment : student_enrolment_id , degree_program_id , semester_id , student_id , other_details \ntable Student_Enrolment_Courses : student_course_id , course_id , student_enrolment_id \ntable Transcripts : transcript_id , transcript_date , other_details \ntable Transcript_Contents : student_course_id , transcript_id\nPrimary keys of columns:\nAddresses : address_id\nCourses : course_id\nDepartments : department_id\nDegree_Programs : degree_program_id\nSections : section_id\nSemesters : semester_id\nStudents : student_id\nStudent_Enrolment : student_enrolment_id\nStudent_Enrolment_Courses : student_course_id\nTranscripts : transcript_id\nTranscript_Contents : \nForeign keys of columns:\nDegree_Programs : department_id equals Departments : department_id\nSections : course_id equals Courses : course_id\nStudents : permanent_address_id equals Addresses : address_id\nStudents : current_address_id equals Addresses : address_id\nStudent_Enrolment : student_id equals Students : student_id\nStudent_Enrolment : semester_id equals Semesters : semester_id\nStudent_Enrolment : degree_program_id equals Degree_Programs : degree_program_id\nStudent_Enrolment_Courses : student_enrolment_id equals Student_Enrolment : student_enrolment_id\nStudent_Enrolment_Courses : course_id equals Courses : course_id\nTranscript_Contents : transcript_id equals Transcripts : transcript_id\nTranscript_Contents : student_course_id equals Student_Enrolment_Courses : student_course_id\nQuestion:\nFind the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nWhat is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nWhat is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable city : ID , Name , CountryCode , District , Population \ntable sqlite_sequence : name , seq \ntable country : Code , Name , Continent , Region , SurfaceArea , IndepYear , Population , LifeExpectancy , GNP , GNPOld , LocalName , GovernmentForm , HeadOfState , Capital , Code2 \ntable countrylanguage : CountryCode , Language , IsOfficial , Percentage\nPrimary keys of columns:\ncity : ID\nsqlite_sequence : \ncountry : Code\ncountrylanguage : CountryCode\nForeign keys of columns:\ncity : CountryCode equals country : Code\ncountrylanguage : CountryCode equals country : Code\nQuestion:\nWhich continent speaks the most languages?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable city : ID , Name , CountryCode , District , Population \ntable sqlite_sequence : name , seq \ntable country : Code , Name , Continent , Region , SurfaceArea , IndepYear , Population , LifeExpectancy , GNP , GNPOld , LocalName , GovernmentForm , HeadOfState , Capital , Code2 \ntable countrylanguage : CountryCode , Language , IsOfficial , Percentage\nPrimary keys of columns:\ncity : ID\nsqlite_sequence : \ncountry : Code\ncountrylanguage : CountryCode\nForeign keys of columns:\ncity : CountryCode equals country : Code\ncountrylanguage : CountryCode equals country : Code\nQuestion:\nWhich continent speaks the most languages?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable city : ID , Name , CountryCode , District , Population \ntable sqlite_sequence : name , seq \ntable country : Code , Name , Continent , Region , SurfaceArea , IndepYear , Population , LifeExpectancy , GNP , GNPOld , LocalName , GovernmentForm , HeadOfState , Capital , Code2 \ntable countrylanguage : CountryCode , Language , IsOfficial , Percentage\nPrimary keys of columns:\ncity : ID\nsqlite_sequence : \ncountry : Code\ncountrylanguage : CountryCode\nForeign keys of columns:\ncity : CountryCode equals country : Code\ncountrylanguage : CountryCode equals country : Code\nQuestion:\nWhat is the language that is used by the largest number of Asian nations?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable city : ID , Name , CountryCode , District , Population \ntable sqlite_sequence : name , seq \ntable country : Code , Name , Continent , Region , SurfaceArea , IndepYear , Population , LifeExpectancy , GNP , GNPOld , LocalName , GovernmentForm , HeadOfState , Capital , Code2 ( by , is ) \ntable countrylanguage : CountryCode , Language , IsOfficial , Percentage\nPrimary keys of columns:\ncity : ID\nsqlite_sequence : \ncountry : Code\ncountrylanguage : CountryCode\nForeign keys of columns:\ncity : CountryCode equals country : Code\ncountrylanguage : CountryCode equals country : Code\nQuestion:\nWhat is the language that is used by the largest number of Asian nations?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable city : ID , Name , CountryCode , District , Population \ntable sqlite_sequence : name , seq \ntable country : Code , Name , Continent , Region , SurfaceArea , IndepYear , Population , LifeExpectancy , GNP , GNPOld , LocalName , GovernmentForm , HeadOfState , Capital , Code2 \ntable countrylanguage : CountryCode , Language , IsOfficial , Percentage\nPrimary keys of columns:\ncity : ID\nsqlite_sequence : \ncountry : Code\ncountrylanguage : CountryCode\nForeign keys of columns:\ncity : CountryCode equals country : Code\ncountrylanguage : CountryCode equals country : Code\nQuestion:\nWhat is the total number of people living in the nations that do not use English?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable city : ID , Name , CountryCode , District , Population \ntable sqlite_sequence : name , seq \ntable country : Code , Name , Continent , Region , SurfaceArea , IndepYear , Population , LifeExpectancy , GNP , GNPOld , LocalName , GovernmentForm , HeadOfState , Capital , Code2 ( in , is , do ) \ntable countrylanguage : CountryCode , Language , IsOfficial , Percentage\nPrimary keys of columns:\ncity : ID\nsqlite_sequence : \ncountry : Code\ncountrylanguage : CountryCode\nForeign keys of columns:\ncity : CountryCode equals country : Code\ncountrylanguage : CountryCode equals country : Code\nQuestion:\nWhat is the total number of people living in the nations that do not use English?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich professionals live in the state of Indiana or have done treatment on more than 2 treatments? List his or her id, last name and cell phone.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id ( 2 ) , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id ( 2 ) , first_name , last_name , street , city , state ( indiana ) , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id ( 2 ) , owner_id ( 2 ) , abandoned_yn , breed_code , size_code , name , age ( 2 ) , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id ( 2 ) , role_code , first_name , street , city , state ( indiana ) , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id ( 2 ) , dog_id ( 2 ) , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich professionals live in the state of Indiana or have done treatment on more than 2 treatments? List his or her id, last name and cell phone.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich owner has paid for the most treatments on his or her dogs? List the owner id and last name.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich owner has paid for the most treatments on his or her dogs? List the owner id and last name.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhat is the description of the treatment type that costs the least money in total?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhat is the description of the treatment type that costs the least money in total?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich owner has paid the largest amount of money in total for their dogs? Show the owner id and zip code.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich owner has paid the largest amount of money in total for their dogs? Show the owner id and zip code.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich professionals have operated a treatment that costs less than the average? Give me theor first names and last names.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich professionals have operated a treatment that costs less than the average? Give me theor first names and last names.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nList the names of the dogs of the rarest breed and the treatment dates of them.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nList the names of the dogs of the rarest breed and the treatment dates of them.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nHow many professionals did not operate any treatment on dogs?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nHow many professionals did not operate any treatment on dogs?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the model of the car with the smallest amount of horsepower?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the model of the car with the smallest amount of horsepower?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable course : Course_ID , Staring_Date , Course \ntable teacher : Teacher_ID , Name , Age , Hometown \ntable course_arrange : Course_ID , Teacher_ID , Grade\nPrimary keys of columns:\ncourse : Course_ID\nteacher : Teacher_ID\ncourse_arrange : Course_ID\nForeign keys of columns:\ncourse_arrange : Teacher_ID equals teacher : Teacher_ID\ncourse_arrange : Course_ID equals course : Course_ID\nQuestion:\nWhat are the names of the teachers whose courses have not been arranged?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable course : Course_ID , Staring_Date , Course \ntable teacher : Teacher_ID , Name , Age , Hometown \ntable course_arrange : Course_ID , Teacher_ID , Grade\nPrimary keys of columns:\ncourse : Course_ID\nteacher : Teacher_ID\ncourse_arrange : Course_ID\nForeign keys of columns:\ncourse_arrange : Teacher_ID equals teacher : Teacher_ID\ncourse_arrange : Course_ID equals course : Course_ID\nQuestion:\nWhat are the names of the teachers whose courses have not been arranged?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nWhat are the countries that are not playing cartoons written by Todd Casey?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nWhat are the countries that are not playing cartoons written by Todd Casey?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nfind the id of tv channels that do not play any cartoon directed by Ben Jones.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nfind the id of tv channels that do not play any cartoon directed by Ben Jones.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Highschooler : ID , name , grade \ntable Friend : student_id , friend_id \ntable Likes : student_id , liked_id\nPrimary keys of columns:\nHighschooler : ID\nFriend : student_id\nLikes : student_id\nForeign keys of columns:\nFriend : friend_id equals Highschooler : ID\nFriend : student_id equals Highschooler : ID\nLikes : student_id equals Highschooler : ID\nLikes : liked_id equals Highschooler : ID\nQuestion:\nFind the average grade of all students who have some friends.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Highschooler : ID , name , grade \ntable Friend : student_id , friend_id \ntable Likes : student_id , liked_id\nPrimary keys of columns:\nHighschooler : ID\nFriend : student_id\nLikes : student_id\nForeign keys of columns:\nFriend : friend_id equals Highschooler : ID\nFriend : student_id equals Highschooler : ID\nLikes : student_id equals Highschooler : ID\nLikes : liked_id equals Highschooler : ID\nQuestion:\nFind the average grade of all students who have some friends.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the name of the country with the most car makers?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the name of the country with the most car makers?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the name of the country with the most car makers?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the name of the country with the most car makers?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the name of the country with the most car makers?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the name of the country with the most car makers?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the name of the country with the most car makers?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the name of the country with the most car makers?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the name of the country with the most car makers?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the name of the country with the most car makers?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the name of the country with the most car makers?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable airlines : uid , Airline , Abbreviation , Country \ntable airports : City , AirportCode , AirportName , Country , CountryAbbrev \ntable flights : Airline , FlightNo , SourceAirport , DestAirport\nPrimary keys of columns:\nairlines : uid\nairports : AirportCode\nflights : Airline\nForeign keys of columns:\nflights : DestAirport equals airports : AirportCode\nflights : SourceAirport equals airports : AirportCode\nQuestion:\nGive the code of the airport with the least flights.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable airlines : uid , Airline , Abbreviation , Country \ntable airports : City , AirportCode , AirportName , Country , CountryAbbrev \ntable flights : Airline , FlightNo , SourceAirport , DestAirport\nPrimary keys of columns:\nairlines : uid\nairports : AirportCode\nflights : Airline\nForeign keys of columns:\nflights : DestAirport equals airports : AirportCode\nflights : SourceAirport equals airports : AirportCode\nQuestion:\nGive the code of the airport with the least flights.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable employee : Employee_ID , Name , Age , City \ntable shop : Shop_ID , Name , Location , District , Number_products , Manager_name \ntable hiring : Shop_ID , Employee_ID , Start_from , Is_full_time \ntable evaluation : Employee_ID , Year_awarded , Bonus\nPrimary keys of columns:\nemployee : Employee_ID\nshop : Shop_ID\nhiring : Employee_ID\nevaluation : Employee_ID\nForeign keys of columns:\nhiring : Employee_ID equals employee : Employee_ID\nhiring : Shop_ID equals shop : Shop_ID\nevaluation : Employee_ID equals employee : Employee_ID\nQuestion:\nWhich employee received the most awards in evaluations? Give me the employee name.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable employee : Employee_ID , Name , Age , City \ntable shop : Shop_ID , Name , Location , District , Number_products , Manager_name \ntable hiring : Shop_ID , Employee_ID , Start_from , Is_full_time \ntable evaluation : Employee_ID , Year_awarded , Bonus\nPrimary keys of columns:\nemployee : Employee_ID\nshop : Shop_ID\nhiring : Employee_ID\nevaluation : Employee_ID\nForeign keys of columns:\nhiring : Employee_ID equals employee : Employee_ID\nhiring : Shop_ID equals shop : Shop_ID\nevaluation : Employee_ID equals employee : Employee_ID\nQuestion:\nWhich employee received the most awards in evaluations? Give me the employee name.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Ref_Template_Types : Template_Type_Code , Template_Type_Description \ntable Templates : Template_ID , Version_Number , Template_Type_Code , Date_Effective_From , Date_Effective_To , Template_Details \ntable Documents : Document_ID , Template_ID , Document_Name , Document_Description , Other_Details \ntable Paragraphs : Paragraph_ID , Document_ID , Paragraph_Text , Other_Details\nPrimary keys of columns:\nRef_Template_Types : Template_Type_Code\nTemplates : Template_ID\nDocuments : Document_ID\nParagraphs : Paragraph_ID\nForeign keys of columns:\nTemplates : Template_Type_Code equals Ref_Template_Types : Template_Type_Code\nDocuments : Template_ID equals Templates : Template_ID\nParagraphs : Document_ID equals Documents : Document_ID\nQuestion:\nReturn the id and type code of the template that is used for the greatest number of documents.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Ref_Template_Types : Template_Type_Code , Template_Type_Description \ntable Templates : Template_ID , Version_Number , Template_Type_Code , Date_Effective_From , Date_Effective_To , Template_Details \ntable Documents : Document_ID , Template_ID , Document_Name , Document_Description , Other_Details \ntable Paragraphs : Paragraph_ID , Document_ID , Paragraph_Text , Other_Details\nPrimary keys of columns:\nRef_Template_Types : Template_Type_Code\nTemplates : Template_ID\nDocuments : Document_ID\nParagraphs : Paragraph_ID\nForeign keys of columns:\nTemplates : Template_Type_Code equals Ref_Template_Types : Template_Type_Code\nDocuments : Template_ID equals Templates : Template_ID\nParagraphs : Document_ID equals Documents : Document_ID\nQuestion:\nReturn the id and type code of the template that is used for the greatest number of documents.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Ref_Template_Types : Template_Type_Code , Template_Type_Description \ntable Templates : Template_ID , Version_Number , Template_Type_Code , Date_Effective_From , Date_Effective_To , Template_Details \ntable Documents : Document_ID , Template_ID , Document_Name , Document_Description , Other_Details \ntable Paragraphs : Paragraph_ID , Document_ID , Paragraph_Text , Other_Details\nPrimary keys of columns:\nRef_Template_Types : Template_Type_Code\nTemplates : Template_ID\nDocuments : Document_ID\nParagraphs : Paragraph_ID\nForeign keys of columns:\nTemplates : Template_Type_Code equals Ref_Template_Types : Template_Type_Code\nDocuments : Template_ID equals Templates : Template_ID\nParagraphs : Document_ID equals Documents : Document_ID\nQuestion:\nWhat is the document id and name with greatest number of paragraphs?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Ref_Template_Types : Template_Type_Code , Template_Type_Description \ntable Templates : Template_ID , Version_Number , Template_Type_Code , Date_Effective_From , Date_Effective_To , Template_Details \ntable Documents : Document_ID , Template_ID , Document_Name , Document_Description , Other_Details \ntable Paragraphs : Paragraph_ID , Document_ID , Paragraph_Text , Other_Details\nPrimary keys of columns:\nRef_Template_Types : Template_Type_Code\nTemplates : Template_ID\nDocuments : Document_ID\nParagraphs : Paragraph_ID\nForeign keys of columns:\nTemplates : Template_Type_Code equals Ref_Template_Types : Template_Type_Code\nDocuments : Template_ID equals Templates : Template_ID\nParagraphs : Document_ID equals Documents : Document_ID\nQuestion:\nWhat is the document id and name with greatest number of paragraphs?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable museum : Museum_ID , Name , Num_of_Staff , Open_Year \ntable visitor : ID , Name , Level_of_membership , Age \ntable visit : Museum_ID , visitor_ID , Num_of_Ticket , Total_spent\nPrimary keys of columns:\nmuseum : Museum_ID\nvisitor : ID\nvisit : Museum_ID\nForeign keys of columns:\nvisit : visitor_ID equals visitor : ID\nvisit : Museum_ID equals museum : Museum_ID\nQuestion:\nWhat are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable museum : Museum_ID , Name , Num_of_Staff , Open_Year \ntable visitor : ID , Name , Level_of_membership , Age \ntable visit : Museum_ID , visitor_ID , Num_of_Ticket , Total_spent\nPrimary keys of columns:\nmuseum : Museum_ID\nvisitor : ID\nvisit : Museum_ID\nForeign keys of columns:\nvisit : visitor_ID equals visitor : ID\nvisit : Museum_ID equals museum : Museum_ID\nQuestion:\nWhat are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable battle : id , name , date , bulgarian_commander , latin_commander , result \ntable ship : lost_in_battle , id , name , tonnage , ship_type , location , disposition_of_ship \ntable death : caused_by_ship_id , id , note , killed , injured\nPrimary keys of columns:\nbattle : id\nship : id\ndeath : id\nForeign keys of columns:\nship : lost_in_battle equals battle : id\ndeath : caused_by_ship_id equals ship : id\nQuestion:\nHow many battles did not lose any ship with tonnage '225'?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable battle : id , name , date , bulgarian_commander , latin_commander , result \ntable ship : lost_in_battle , id , name , tonnage , ship_type , location , disposition_of_ship \ntable death : caused_by_ship_id , id , note , killed , injured\nPrimary keys of columns:\nbattle : id\nship : id\ndeath : id\nForeign keys of columns:\nship : lost_in_battle equals battle : id\ndeath : caused_by_ship_id equals ship : id\nQuestion:\nHow many battles did not lose any ship with tonnage '225'?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Addresses : address_id , line_1 , line_2 , line_3 , city , zip_postcode , state_province_county , country , other_address_details \ntable Courses : course_id , course_name , course_description , other_details \ntable Departments : department_id , department_name , department_description , other_details \ntable Degree_Programs : degree_program_id , department_id , degree_summary_name , degree_summary_description , other_details \ntable Sections : section_id , course_id , section_name , section_description , other_details \ntable Semesters : semester_id , semester_name , semester_description , other_details \ntable Students : student_id , current_address_id , permanent_address_id , first_name , middle_name , last_name , cell_mobile_number , email_address , ssn , date_first_registered , date_left , other_student_details \ntable Student_Enrolment : student_enrolment_id , degree_program_id , semester_id , student_id , other_details \ntable Student_Enrolment_Courses : student_course_id , course_id , student_enrolment_id \ntable Transcripts : transcript_id , transcript_date , other_details \ntable Transcript_Contents : student_course_id , transcript_id\nPrimary keys of columns:\nAddresses : address_id\nCourses : course_id\nDepartments : department_id\nDegree_Programs : degree_program_id\nSections : section_id\nSemesters : semester_id\nStudents : student_id\nStudent_Enrolment : student_enrolment_id\nStudent_Enrolment_Courses : student_course_id\nTranscripts : transcript_id\nTranscript_Contents : \nForeign keys of columns:\nDegree_Programs : department_id equals Departments : department_id\nSections : course_id equals Courses : course_id\nStudents : permanent_address_id equals Addresses : address_id\nStudents : current_address_id equals Addresses : address_id\nStudent_Enrolment : student_id equals Students : student_id\nStudent_Enrolment : semester_id equals Semesters : semester_id\nStudent_Enrolment : degree_program_id equals Degree_Programs : degree_program_id\nStudent_Enrolment_Courses : student_enrolment_id equals Student_Enrolment : student_enrolment_id\nStudent_Enrolment_Courses : course_id equals Courses : course_id\nTranscript_Contents : transcript_id equals Transcripts : transcript_id\nTranscript_Contents : student_course_id equals Student_Enrolment_Courses : student_course_id\nQuestion:\nFind the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Addresses : address_id , line_1 , line_2 , line_3 , city , zip_postcode , state_province_county , country , other_address_details \ntable Courses : course_id , course_name , course_description , other_details \ntable Departments : department_id , department_name , department_description ( in ) , other_details \ntable Degree_Programs : degree_program_id , department_id , degree_summary_name , degree_summary_description , other_details \ntable Sections : section_id , course_id , section_name , section_description , other_details \ntable Semesters : semester_id , semester_name , semester_description , other_details \ntable Students : student_id , current_address_id , permanent_address_id , first_name , middle_name , last_name , cell_mobile_number , email_address , ssn , date_first_registered , date_left , other_student_details \ntable Student_Enrolment : student_enrolment_id , degree_program_id , semester_id , student_id , other_details \ntable Student_Enrolment_Courses : student_course_id , course_id , student_enrolment_id \ntable Transcripts : transcript_id , transcript_date , other_details \ntable Transcript_Contents : student_course_id , transcript_id\nPrimary keys of columns:\nAddresses : address_id\nCourses : course_id\nDepartments : department_id\nDegree_Programs : degree_program_id\nSections : section_id\nSemesters : semester_id\nStudents : student_id\nStudent_Enrolment : student_enrolment_id\nStudent_Enrolment_Courses : student_course_id\nTranscripts : transcript_id\nTranscript_Contents : \nForeign keys of columns:\nDegree_Programs : department_id equals Departments : department_id\nSections : course_id equals Courses : course_id\nStudents : permanent_address_id equals Addresses : address_id\nStudents : current_address_id equals Addresses : address_id\nStudent_Enrolment : student_id equals Students : student_id\nStudent_Enrolment : semester_id equals Semesters : semester_id\nStudent_Enrolment : degree_program_id equals Degree_Programs : degree_program_id\nStudent_Enrolment_Courses : student_enrolment_id equals Student_Enrolment : student_enrolment_id\nStudent_Enrolment_Courses : course_id equals Courses : course_id\nTranscript_Contents : transcript_id equals Transcripts : transcript_id\nTranscript_Contents : student_course_id equals Student_Enrolment_Courses : student_course_id\nQuestion:\nFind the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nWhat is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nWhat is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable city : ID , Name , CountryCode , District , Population \ntable sqlite_sequence : name , seq \ntable country : Code , Name , Continent , Region , SurfaceArea , IndepYear , Population , LifeExpectancy , GNP , GNPOld , LocalName , GovernmentForm , HeadOfState , Capital , Code2 \ntable countrylanguage : CountryCode , Language , IsOfficial , Percentage\nPrimary keys of columns:\ncity : ID\nsqlite_sequence : \ncountry : Code\ncountrylanguage : CountryCode\nForeign keys of columns:\ncity : CountryCode equals country : Code\ncountrylanguage : CountryCode equals country : Code\nQuestion:\nWhich continent speaks the most languages?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable city : ID , Name , CountryCode , District , Population \ntable sqlite_sequence : name , seq \ntable country : Code , Name , Continent , Region , SurfaceArea , IndepYear , Population , LifeExpectancy , GNP , GNPOld , LocalName , GovernmentForm , HeadOfState , Capital , Code2 \ntable countrylanguage : CountryCode , Language , IsOfficial , Percentage\nPrimary keys of columns:\ncity : ID\nsqlite_sequence : \ncountry : Code\ncountrylanguage : CountryCode\nForeign keys of columns:\ncity : CountryCode equals country : Code\ncountrylanguage : CountryCode equals country : Code\nQuestion:\nWhich continent speaks the most languages?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable city : ID , Name , CountryCode , District , Population \ntable sqlite_sequence : name , seq \ntable country : Code , Name , Continent , Region , SurfaceArea , IndepYear , Population , LifeExpectancy , GNP , GNPOld , LocalName , GovernmentForm , HeadOfState , Capital , Code2 \ntable countrylanguage : CountryCode , Language , IsOfficial , Percentage\nPrimary keys of columns:\ncity : ID\nsqlite_sequence : \ncountry : Code\ncountrylanguage : CountryCode\nForeign keys of columns:\ncity : CountryCode equals country : Code\ncountrylanguage : CountryCode equals country : Code\nQuestion:\nWhat is the language that is used by the largest number of Asian nations?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable city : ID , Name , CountryCode , District , Population \ntable sqlite_sequence : name , seq \ntable country : Code , Name , Continent , Region , SurfaceArea , IndepYear , Population , LifeExpectancy , GNP , GNPOld , LocalName , GovernmentForm , HeadOfState , Capital , Code2 ( by , is ) \ntable countrylanguage : CountryCode , Language , IsOfficial , Percentage\nPrimary keys of columns:\ncity : ID\nsqlite_sequence : \ncountry : Code\ncountrylanguage : CountryCode\nForeign keys of columns:\ncity : CountryCode equals country : Code\ncountrylanguage : CountryCode equals country : Code\nQuestion:\nWhat is the language that is used by the largest number of Asian nations?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable city : ID , Name , CountryCode , District , Population \ntable sqlite_sequence : name , seq \ntable country : Code , Name , Continent , Region , SurfaceArea , IndepYear , Population , LifeExpectancy , GNP , GNPOld , LocalName , GovernmentForm , HeadOfState , Capital , Code2 \ntable countrylanguage : CountryCode , Language , IsOfficial , Percentage\nPrimary keys of columns:\ncity : ID\nsqlite_sequence : \ncountry : Code\ncountrylanguage : CountryCode\nForeign keys of columns:\ncity : CountryCode equals country : Code\ncountrylanguage : CountryCode equals country : Code\nQuestion:\nWhat is the total number of people living in the nations that do not use English?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable city : ID , Name , CountryCode , District , Population \ntable sqlite_sequence : name , seq \ntable country : Code , Name , Continent , Region , SurfaceArea , IndepYear , Population , LifeExpectancy , GNP , GNPOld , LocalName , GovernmentForm , HeadOfState , Capital , Code2 ( in , do , is ) \ntable countrylanguage : CountryCode , Language , IsOfficial , Percentage\nPrimary keys of columns:\ncity : ID\nsqlite_sequence : \ncountry : Code\ncountrylanguage : CountryCode\nForeign keys of columns:\ncity : CountryCode equals country : Code\ncountrylanguage : CountryCode equals country : Code\nQuestion:\nWhat is the total number of people living in the nations that do not use English?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich professionals live in the state of Indiana or have done treatment on more than 2 treatments? List his or her id, last name and cell phone.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id ( 2 ) , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id ( 2 ) , first_name , last_name , street , city , state ( indiana ) , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id ( 2 ) , owner_id ( 2 ) , abandoned_yn , breed_code , size_code , name , age ( 2 ) , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id ( 2 ) , role_code , first_name , street , city , state ( indiana ) , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id ( 2 ) , dog_id ( 2 ) , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich professionals live in the state of Indiana or have done treatment on more than 2 treatments? List his or her id, last name and cell phone.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich owner has paid for the most treatments on his or her dogs? List the owner id and last name.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich owner has paid for the most treatments on his or her dogs? List the owner id and last name.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhat is the description of the treatment type that costs the least money in total?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhat is the description of the treatment type that costs the least money in total?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich owner has paid the largest amount of money in total for their dogs? Show the owner id and zip code.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich owner has paid the largest amount of money in total for their dogs? Show the owner id and zip code.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich professionals have operated a treatment that costs less than the average? Give me theor first names and last names.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nWhich professionals have operated a treatment that costs less than the average? Give me theor first names and last names.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nList the names of the dogs of the rarest breed and the treatment dates of them.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nList the names of the dogs of the rarest breed and the treatment dates of them.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nHow many professionals did not operate any treatment on dogs?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Breeds : breed_code , breed_name \ntable Charges : charge_id , charge_type , charge_amount \ntable Sizes : size_code , size_description \ntable Treatment_Types : treatment_type_code , treatment_type_description \ntable Owners : owner_id , first_name , last_name , street , city , state , zip_code , email_address , home_phone , cell_number \ntable Dogs : dog_id , owner_id , abandoned_yn , breed_code , size_code , name , age , date_of_birth , gender , weight , date_arrived , date_adopted , date_departed \ntable Professionals : professional_id , role_code , first_name , street , city , state , zip_code , last_name , email_address , home_phone , cell_number \ntable Treatments : treatment_id , dog_id , professional_id , treatment_type_code , date_of_treatment , cost_of_treatment\nPrimary keys of columns:\nBreeds : breed_code\nCharges : charge_id\nSizes : size_code\nTreatment_Types : treatment_type_code\nOwners : owner_id\nDogs : dog_id\nProfessionals : professional_id\nTreatments : treatment_id\nForeign keys of columns:\nDogs : owner_id equals Owners : owner_id\nDogs : owner_id equals Owners : owner_id\nDogs : size_code equals Sizes : size_code\nDogs : breed_code equals Breeds : breed_code\nTreatments : dog_id equals Dogs : dog_id\nTreatments : professional_id equals Professionals : professional_id\nTreatments : treatment_type_code equals Treatment_Types : treatment_type_code\nQuestion:\nHow many professionals did not operate any treatment on dogs?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the model of the car with the smallest amount of horsepower?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the model of the car with the smallest amount of horsepower?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the model of the car with the smallest amount of horsepower?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable continents : ContId , Continent \ntable countries : CountryId , CountryName , Continent \ntable car_makers : Id , Maker , FullName , Country \ntable model_list : ModelId , Maker , Model \ntable car_names : MakeId , Model , Make \ntable cars_data : Id , MPG , Cylinders , Edispl , Horsepower , Weight , Accelerate , Year\nPrimary keys of columns:\ncontinents : ContId\ncountries : CountryId\ncar_makers : Id\nmodel_list : ModelId\ncar_names : MakeId\ncars_data : Id\nForeign keys of columns:\ncountries : Continent equals continents : ContId\ncar_makers : Country equals countries : CountryId\nmodel_list : Maker equals car_makers : Id\ncar_names : Model equals model_list : Model\ncars_data : Id equals car_names : MakeId\nQuestion:\nWhat is the model of the car with the smallest amount of horsepower?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable course : Course_ID , Staring_Date , Course \ntable teacher : Teacher_ID , Name , Age , Hometown \ntable course_arrange : Course_ID , Teacher_ID , Grade\nPrimary keys of columns:\ncourse : Course_ID\nteacher : Teacher_ID\ncourse_arrange : Course_ID\nForeign keys of columns:\ncourse_arrange : Teacher_ID equals teacher : Teacher_ID\ncourse_arrange : Course_ID equals course : Course_ID\nQuestion:\nWhat are the names of the teachers whose courses have not been arranged?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable course : Course_ID , Staring_Date , Course \ntable teacher : Teacher_ID , Name , Age , Hometown \ntable course_arrange : Course_ID , Teacher_ID , Grade\nPrimary keys of columns:\ncourse : Course_ID\nteacher : Teacher_ID\ncourse_arrange : Course_ID\nForeign keys of columns:\ncourse_arrange : Teacher_ID equals teacher : Teacher_ID\ncourse_arrange : Course_ID equals course : Course_ID\nQuestion:\nWhat are the names of the teachers whose courses have not been arranged?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nWhat are the countries that are not playing cartoons written by Todd Casey?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nWhat are the countries that are not playing cartoons written by Todd Casey?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nfind the id of tv channels that do not play any cartoon directed by Ben Jones.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nfind the id of tv channels that do not play any cartoon directed by Ben Jones.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nfind the id of tv channels that do not play any cartoon directed by Ben Jones.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nfind the id of tv channels that do not play any cartoon directed by Ben Jones.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nfind the id of tv channels that do not play any cartoon directed by Ben Jones.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable TV_Channel : id , series_name , Country , Language , Content , Pixel_aspect_ratio_PAR , Hight_definition_TV , Pay_per_view_PPV , Package_Option \ntable TV_series : id , Episode , Air_Date , Rating , Share , 18_49_Rating_Share , Viewers_m , Weekly_Rank , Channel \ntable Cartoon : id , Title , Directed_by , Written_by , Original_air_date , Production_code , Channel\nPrimary keys of columns:\nTV_Channel : id\nTV_series : id\nCartoon : id\nForeign keys of columns:\nTV_series : Channel equals TV_Channel : id\nCartoon : Channel equals TV_Channel : id\nQuestion:\nfind the id of tv channels that do not play any cartoon directed by Ben Jones.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Highschooler : ID , name , grade \ntable Friend : student_id , friend_id \ntable Likes : student_id , liked_id\nPrimary keys of columns:\nHighschooler : ID\nFriend : student_id\nLikes : student_id\nForeign keys of columns:\nFriend : friend_id equals Highschooler : ID\nFriend : student_id equals Highschooler : ID\nLikes : student_id equals Highschooler : ID\nLikes : liked_id equals Highschooler : ID\nQuestion:\nFind the average grade of all students who have some friends.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Highschooler : ID , name , grade \ntable Friend : student_id , friend_id \ntable Likes : student_id , liked_id\nPrimary keys of columns:\nHighschooler : ID\nFriend : student_id\nLikes : student_id\nForeign keys of columns:\nFriend : friend_id equals Highschooler : ID\nFriend : student_id equals Highschooler : ID\nLikes : student_id equals Highschooler : ID\nLikes : liked_id equals Highschooler : ID\nQuestion:\nFind the average grade of all students who have some friends.\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:""QPL is a formalism used to describe data retrieval operations over an SQL schema in a modular manner.\nA QPL plan is a sequence of instructions for querying tabular data to answer a natural language question.\nForget everything you know about SQL, only use the following explanations.\n\nA schema is specified as a list of <table> specification in the format:\n<table>: <comma separated list of columns>\n\nA plan contains a sequence of operations.\nAll operations return a stream of tuples.\nAll operations take as input either a physical table from the schema (for the Scan operation) or the output of other operations.\n\nYour task is to learn the QPL BNF and the examples and to provide only the QPL plan according to the schema and the \nquestion I will give you below.\n\nThis is the formal specification for each operation:\n\n<qpl> ::= <line>+\n<line> ::= # <integer> = <operator>\n<operator> ::= <scan> | <aggregate> | <filter> | <sort> | <join> | <except> | <intersect> | <union>\n<scan> ::= Scan Table [ <table-name> ] <predicate>? <distinct>? <output-list-non-qualified>\n<aggregate> ::= Aggregate [ <input> ] <group-by>? <output-list-non-qualified>\n<filter> ::= Filter [ <input> ] <predicate> <distinct>? <output-list-non-qualified>\n<sort> ::= Sort [ <input> ] <order-by> <output-list-non-qualified>\n<join> ::= Join [ <input> , <input> ] <predicate>? <distinct>? <output-list-qualified>\n<except> ::= Except [ <input> , <input> ] <predicate> <output-list-qualified>\n<intersect> ::= Intersect [ <input> , <input> ] <predicate>? <output-list-qualified>\n<union> ::= Union [ <input> , <input> ] <output-list-qualified>\n<group-by> ::= GroupBy [ <column-name> (, <column-name>)* ]\n<order-by> ::= OrderBy [ <column-name> <direction> (, <column-name> <direction>)* ]\n<direction> ::= ASC | DESC\n<predicate> ::= Predicate [ <comparison> (AND | OR <comparison)* ]\n<distinct> ::= Distinct [ true ]\n<output-list-non-qualified> ::= Output [ <column-name> (, <column-name>)* ]\n<output-list-qualified> ::= Output [ <qualified-column-name> (, <qualified-column-name>)* ]\n<qualified-column-name> ::= # <number> . <column-name>\n\nExample 1:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the title of the album that was released by the artist whose name has the phrase 'Led'?\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 2:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( albums ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList the name of albums that are released by aritist whose name has 'Led'\n\nQPL Plan:\n#1 = Scan Table [ artists ] Predicate [ name like '%Led%' ] Output [ id , name ] ; #2 = Scan Table [ albums ] Output [ title , artist_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.artist_id = #1.id ] Output [ #2.title ]\n\nExample 3:\n\nSchema: \ntable Products : product_id , product_name , product_price , product_description \ntable Addresses : address_id , address_details , city , zip_postcode , state_province_county , country \ntable Customers : customer_id , payment_method , customer_name , customer_phone , customer_email , date_became_customer \ntable Regular_Orders : regular_order_id , distributer_id \ntable Regular_Order_Products : regular_order_id , product_id \ntable Actual_Orders : actual_order_id , order_status_code , regular_order_id , actual_order_date \ntable Actual_Order_Products : actual_order_id , product_id \ntable Customer_Addresses : customer_id , address_id , date_from , address_type , date_to \ntable Delivery_Routes : route_id , route_name , other_route_details \ntable Delivery_Route_Locations : location_code , route_id , location_address_id , location_name \ntable Trucks : truck_id , truck_licence_number , truck_details \ntable Employees : employee_id , employee_address_id , employee_name , employee_phone \ntable Order_Deliveries : location_code , actual_order_id , delivery_status_code , driver_employee_id , truck_id , delivery_date\nPrimary keys of columns:\nProducts : product_id\nAddresses : address_id\nCustomers : customer_id\nRegular_Orders : regular_order_id\nRegular_Order_Products : \nActual_Orders : actual_order_id\nActual_Order_Products : \nCustomer_Addresses : \nDelivery_Routes : route_id\nDelivery_Route_Locations : location_code\nTrucks : truck_id\nEmployees : employee_id\nOrder_Deliveries : \nForeign keys of columns:\nRegular_Orders : distributer_id equals Customers : customer_id\nRegular_Order_Products : regular_order_id equals Regular_Orders : regular_order_id\nRegular_Order_Products : product_id equals Products : product_id\nActual_Orders : regular_order_id equals Regular_Orders : regular_order_id\nActual_Order_Products : actual_order_id equals Actual_Orders : actual_order_id\nActual_Order_Products : product_id equals Products : product_id\nCustomer_Addresses : address_id equals Addresses : address_id\nCustomer_Addresses : customer_id equals Customers : customer_id\nDelivery_Route_Locations : route_id equals Delivery_Routes : route_id\nDelivery_Route_Locations : location_address_id equals Addresses : address_id\nEmployees : employee_address_id equals Addresses : address_id\nOrder_Deliveries : driver_employee_id equals Employees : employee_id\nOrder_Deliveries : location_code equals Delivery_Route_Locations : location_code\nOrder_Deliveries : actual_order_id equals Actual_Orders : actual_order_id\nOrder_Deliveries : truck_id equals Trucks : truck_id\nQuestion:\nFind the names of customers who are not living in the state of California.\n\nQPL Plan:\n#1 = Scan Table [ Customers ] Distinct [ true ] Output [ customer_name ] ; #2 = Scan Table [ Customers ] Output [ customer_id , customer_name ] ; #3 = Scan Table [ Addresses ] Predicate [ state_province_county = 'California' ] Output [ state_province_county , address_id ] ; #4 = Scan Table [ Customer_Addresses ] Output [ customer_id , address_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.address_id = #3.address_id ] Output [ #4.customer_id ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.customer_id = #2.customer_id ] Distinct [ true ] Output [ #2.customer_name ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.customer_name = #6.customer_name ] Output [ #1.customer_name ]\n\nExample 4:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name ( tracks ) , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name ( daan ) , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nList all tracks bought by customer Daan Peeters.\n\nQPL Plan:\n#1 = Scan Table [ tracks ] Output [ id , name ] ; #2 = Scan Table [ customers ] Predicate [ first_name = 'Daan' AND last_name = 'Peeters' ] Output [ id , first_name , last_name ] ; #3 = Scan Table [ invoices ] Output [ id , customer_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.customer_id = #2.id ] Output [ #3.id ] ; #5 = Scan Table [ invoice_lines ] Output [ track_id , invoice_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.invoice_id = #4.id ] Output [ #5.track_id ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.track_id = #1.id ] Output [ #1.name ]\n\nExample 5:\n\nSchema: \ntable artists : id , name \ntable sqlite_sequence : name , seq \ntable albums : id , title , artist_id \ntable employees : id , last_name , first_name , title , reports_to , birth_date , hire_date , address , city , state , country , postal_code , phone , fax , email \ntable customers : id , first_name , last_name , company , address , city , state , country , postal_code , phone , fax , email , support_rep_id \ntable genres : id , name \ntable invoices : id , customer_id , invoice_date , billing_address , billing_city , billing_state , billing_country , billing_postal_code , total \ntable media_types : id , name \ntable tracks : id , name , album_id , media_type_id , genre_id , composer , milliseconds , bytes , unit_price \ntable invoice_lines : id , invoice_id , track_id , unit_price , quantity \ntable playlists : id , name \ntable playlist_tracks : playlist_id , track_id\nPrimary keys of columns:\nartists : id\nsqlite_sequence : \nalbums : id\nemployees : id\ncustomers : id\ngenres : id\ninvoices : id\nmedia_types : id\ntracks : id\ninvoice_lines : id\nplaylists : id\nplaylist_tracks : playlist_id\nForeign keys of columns:\nalbums : artist_id equals artists : id\nemployees : reports_to equals employees : id\ncustomers : support_rep_id equals employees : id\ninvoices : customer_id equals customers : id\ntracks : media_type_id equals media_types : id\ntracks : genre_id equals genres : id\ntracks : album_id equals albums : id\ninvoice_lines : track_id equals tracks : id\ninvoice_lines : invoice_id equals invoices : id\nplaylist_tracks : track_id equals tracks : id\nplaylist_tracks : playlist_id equals playlists : id\nQuestion:\nWhat is the full name of the employee who has the most customers?\n\nQPL Plan:\n#1 = Scan Table [ employees ] Output [ id , first_name , last_name ] ; #2 = Scan Table [ customers ] Output [ support_rep_id ] ; #3 = Aggregate [ #2 ] GroupBy [ support_rep_id ] Output [ countstar AS Count_Star , support_rep_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.support_rep_id = #1.id ] Output [ #1.first_name , #3.Count_Star , #1.last_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , Count_Star ]\n\nExample 6:\n\nSchema: \ntable Campuses : Id , Campus , Location , County , Year \ntable csu_fees : Campus , Year , CampusFee \ntable degrees : Year , Campus , Degrees \ntable discipline_enrollments : Campus , Discipline , Year , Undergraduate , Graduate \ntable enrollments : Campus , Year , TotalEnrollment_AY , FTE_AY \ntable faculty : Campus , Year , Faculty\nPrimary keys of columns:\nCampuses : Id\ncsu_fees : Campus\ndegrees : Year\ndiscipline_enrollments : Campus\nenrollments : Campus\nfaculty : \nForeign keys of columns:\ncsu_fees : Campus equals Campuses : Id\ndegrees : Campus equals Campuses : Id\ndiscipline_enrollments : Campus equals Campuses : Id\nenrollments : Campus equals Campuses : Id\nfaculty : Campus equals Campuses : Id\nQuestion:\nHow many faculty members are at the university that gave the least number of degrees in 2001?\n\nQPL Plan:\n#1 = Scan Table [ degrees ] Predicate [ Year = 2001 ] Output [ Year , Degrees , Campus ] ; #2 = Scan Table [ faculty ] Predicate [ Year = 2001 ] Output [ Faculty , Year , Campus ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Campus = #1.Campus ] Output [ #2.Faculty , #1.Degrees ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Degrees ASC ] Output [ Faculty , Degrees ]\n\nNow your turn:\n\nSchema: \ntable Student : StuID , LName , Fname , Age , Sex , Major , Advisor , city_code \ntable Has_Pet : StuID , PetID \ntable Pets : PetID , PetType , pet_age , weight\nPrimary keys of columns:\nStudent : StuID\nHas_Pet : \nPets : PetID\nForeign keys of columns:\nHas_Pet : StuID equals Student : StuID\nHas_Pet : PetID equals Pets : PetID\nQuestion:\nWhat is the average age for all students who do not own any pets ?\n\nthe following QPL Plan is:"